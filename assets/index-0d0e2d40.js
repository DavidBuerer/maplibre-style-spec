import{c as m,g as J,i as g,b as ke,t as Z,d as Ir,s as Mr,a as x}from"./entry-client-a5805616.js";import{s as Er}from"./v8-c0965a88.js";import{P as jr,S as Ar}from"./property-c4e7a0cb.js";import{M as C}from"./markdown-5e4e948c.js";const me={kind:"null"},p={kind:"number"},y={kind:"string"},f={kind:"boolean"},A={kind:"color"},K={kind:"object"},h={kind:"value"},Dr={kind:"error"},ge={kind:"collator"},Ne={kind:"formatted"},ze={kind:"padding"},be={kind:"resolvedImage"};function I(r,e){return{kind:"array",itemType:r,N:e}}function b(r){if(r.kind==="array"){const e=b(r.itemType);return typeof r.N=="number"?`array<${e}, ${r.N}>`:r.itemType.kind==="value"?"array":`array<${e}>`}else return r.kind}const Nr=[me,p,y,f,A,Ne,K,I(h),ze,be];function te(r,e){if(e.kind==="error")return null;if(r.kind==="array"){if(e.kind==="array"&&(e.N===0&&e.itemType.kind==="value"||!te(r.itemType,e.itemType))&&(typeof r.N!="number"||r.N===e.N))return null}else{if(r.kind===e.kind)return null;if(r.kind==="value"){for(const t of Nr)if(!te(t,e))return null}}return`Expected ${b(r)} but found ${b(e)} instead.`}function Oe(r,e){return e.some(t=>t.kind===r.kind)}function re(r,e){return e.some(t=>t==="null"?r===null:t==="array"?Array.isArray(r):t==="object"?r&&!Array.isArray(r)&&typeof r=="object":t===typeof r)}function se(r,e){return r.kind==="array"&&e.kind==="array"?r.itemType.kind===e.itemType.kind&&typeof r.N=="number":r.kind===e.kind}class Pe{constructor(e,t=[]){this.parent=e,this.bindings={};for(const[n,a]of t)this.bindings[n]=a}concat(e){return new Pe(this,e)}get(e){if(this.bindings[e])return this.bindings[e];if(this.parent)return this.parent.get(e);throw new Error(`${e} not found in scope.`)}has(e){return this.bindings[e]?!0:this.parent?this.parent.has(e):!1}}class zr extends Error{constructor(e,t){super(t),this.message=t,this.key=e}}var Ee={},Or={get exports(){return Ee},set exports(r){Ee=r}},Pr={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},je={},Fr={get exports(){return je},set exports(r){je=r}},Lr=function(e){return!e||typeof e=="string"?!1:e instanceof Array||Array.isArray(e)||e.length>=0&&(e.splice instanceof Function||Object.getOwnPropertyDescriptor(e,e.length-1)&&e.constructor.name!=="String")},qr=Lr,Ur=Array.prototype.concat,Rr=Array.prototype.slice,dt=Fr.exports=function(e){for(var t=[],n=0,a=e.length;n<a;n++){var i=e[n];qr(i)?t=Ur.call(t,Rr.call(i)):t.push(i)}return t};dt.wrap=function(r){return function(){return r(dt(arguments))}};var Y=Pr,ae=je,St=Object.hasOwnProperty,Ct=Object.create(null);for(var xe in Y)St.call(Y,xe)&&(Ct[Y[xe]]=xe);var _=Or.exports={to:{},get:{}};_.get=function(r){var e=r.substring(0,3).toLowerCase(),t,n;switch(e){case"hsl":t=_.get.hsl(r),n="hsl";break;case"hwb":t=_.get.hwb(r),n="hwb";break;default:t=_.get.rgb(r),n="rgb";break}return t?{model:n,value:t}:null};_.get.rgb=function(r){if(!r)return null;var e=/^#([a-f0-9]{3,4})$/i,t=/^#([a-f0-9]{6})([a-f0-9]{2})?$/i,n=/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,a=/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,i=/^(\w+)$/,s=[0,0,0,1],o,l,u;if(o=r.match(t)){for(u=o[2],o=o[1],l=0;l<3;l++){var c=l*2;s[l]=parseInt(o.slice(c,c+2),16)}u&&(s[3]=parseInt(u,16)/255)}else if(o=r.match(e)){for(o=o[1],u=o[3],l=0;l<3;l++)s[l]=parseInt(o[l]+o[l],16);u&&(s[3]=parseInt(u+u,16)/255)}else if(o=r.match(n)){for(l=0;l<3;l++)s[l]=parseInt(o[l+1],0);o[4]&&(o[5]?s[3]=parseFloat(o[4])*.01:s[3]=parseFloat(o[4]))}else if(o=r.match(a)){for(l=0;l<3;l++)s[l]=Math.round(parseFloat(o[l+1])*2.55);o[4]&&(o[5]?s[3]=parseFloat(o[4])*.01:s[3]=parseFloat(o[4]))}else return(o=r.match(i))?o[1]==="transparent"?[0,0,0,0]:St.call(Y,o[1])?(s=Y[o[1]],s[3]=1,s):null:null;for(l=0;l<3;l++)s[l]=O(s[l],0,255);return s[3]=O(s[3],0,1),s};_.get.hsl=function(r){if(!r)return null;var e=/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,t=r.match(e);if(t){var n=parseFloat(t[4]),a=(parseFloat(t[1])%360+360)%360,i=O(parseFloat(t[2]),0,100),s=O(parseFloat(t[3]),0,100),o=O(isNaN(n)?1:n,0,1);return[a,i,s,o]}return null};_.get.hwb=function(r){if(!r)return null;var e=/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,t=r.match(e);if(t){var n=parseFloat(t[4]),a=(parseFloat(t[1])%360+360)%360,i=O(parseFloat(t[2]),0,100),s=O(parseFloat(t[3]),0,100),o=O(isNaN(n)?1:n,0,1);return[a,i,s,o]}return null};_.to.hex=function(){var r=ae(arguments);return"#"+oe(r[0])+oe(r[1])+oe(r[2])+(r[3]<1?oe(Math.round(r[3]*255)):"")};_.to.rgb=function(){var r=ae(arguments);return r.length<4||r[3]===1?"rgb("+Math.round(r[0])+", "+Math.round(r[1])+", "+Math.round(r[2])+")":"rgba("+Math.round(r[0])+", "+Math.round(r[1])+", "+Math.round(r[2])+", "+r[3]+")"};_.to.rgb.percent=function(){var r=ae(arguments),e=Math.round(r[0]/255*100),t=Math.round(r[1]/255*100),n=Math.round(r[2]/255*100);return r.length<4||r[3]===1?"rgb("+e+"%, "+t+"%, "+n+"%)":"rgba("+e+"%, "+t+"%, "+n+"%, "+r[3]+")"};_.to.hsl=function(){var r=ae(arguments);return r.length<4||r[3]===1?"hsl("+r[0]+", "+r[1]+"%, "+r[2]+"%)":"hsla("+r[0]+", "+r[1]+"%, "+r[2]+"%, "+r[3]+")"};_.to.hwb=function(){var r=ae(arguments),e="";return r.length>=4&&r[3]!==1&&(e=", "+r[3]),"hwb("+r[0]+", "+r[1]+"%, "+r[2]+"%"+e+")"};_.to.keyword=function(r){return Ct[r.slice(0,3)]};function O(r,e,t){return Math.min(Math.max(e,r),t)}function oe(r){var e=Math.round(r).toString(16).toUpperCase();return e.length<2?"0"+e:e}const _t=.95047,It=1,Mt=1.08883,Et=4/29,X=6/29,jt=3*X*X,Hr=X*X*X,Vr=Math.PI/180,Jr=180/Math.PI;function At(r){return r=r%360,r<0&&(r+=360),r}function Dt([r,e,t,n]){r=$e(r),e=$e(e),t=$e(t);const a=Te((.4124564*r+.3575761*e+.1804375*t)/_t),i=Te((.2126729*r+.7151522*e+.072175*t)/It),s=Te((.0193339*r+.119192*e+.9503041*t)/Mt),o=116*i-16;return[o<0?0:o,500*(a-i),200*(i-s),n]}function $e(r){return r<=.04045?r/12.92:Math.pow((r+.055)/1.055,2.4)}function Te(r){return r>Hr?Math.pow(r,1/3):r/jt+Et}function Nt([r,e,t,n]){let a=(r+16)/116,i=isNaN(e)?a:a+e/500,s=isNaN(t)?a:a-t/200;return a=It*Ce(a),i=_t*Ce(i),s=Mt*Ce(s),[Se(3.2404542*i-1.5371385*a-.4985314*s),Se(-.969266*i+1.8760108*a+.041556*s),Se(.0556434*i-.2040259*a+1.0572252*s),n]}function Se(r){return r=r<=.00304?12.92*r:1.055*Math.pow(r,1/2.4)-.055,r<0?0:r>1?1:r}function Ce(r){return r>X?r*r*r:jt*(r-Et)}function Kr(r){const[e,t,n,a]=Dt(r),i=Math.sqrt(t*t+n*n);return[Math.round(i*1e4)?At(Math.atan2(n,t)*Jr):NaN,i,e,a]}function Xr([r,e,t,n]){return r=isNaN(r)?0:r*Vr,Nt([t,Math.cos(r)*e,Math.sin(r)*e,n])}function Gr([r,e,t,n]){r=At(r),e/=100,t/=100;function a(i){const s=(i+r/30)%12,o=e*Math.min(t,1-t);return t-o*Math.max(-1,Math.min(s-3,9-s,1))}return[a(0),a(8),a(4),n]}class ${constructor(e,t,n,a=1,i=!0){this.r=e,this.g=t,this.b=n,this.a=a,i||(this.r*=a,this.g*=a,this.b*=a,a||this.overwriteGetter("rgb",[e,t,n,a]))}static parse(e){if(typeof e!="string")return;const t=Wr(e.toLowerCase());if(t)return new $(...t,!1)}get rgb(){const{r:e,g:t,b:n,a}=this,i=a||1/0;return this.overwriteGetter("rgb",[e/i,t/i,n/i,a])}get hcl(){return this.overwriteGetter("hcl",Kr(this.rgb))}get lab(){return this.overwriteGetter("lab",Dt(this.rgb))}overwriteGetter(e,t){return Object.defineProperty(this,e,{value:t}),t}toString(){const[e,t,n,a]=this.rgb;return`rgba(${[e,t,n].map(i=>Math.round(i*255)).join(",")},${a})`}}function Wr(r){const e=Ee.get(r);switch(e?.model){case"rgb":{const[t,n,a,i]=e.value;return[t/255,n/255,a/255,i]}case"hsl":return Gr(e.value)}}$.black=new $(0,0,0,1);$.white=new $(1,1,1,1);$.transparent=new $(0,0,0,0);$.red=new $(1,0,0,1);class Fe{constructor(e,t,n){e?this.sensitivity=t?"variant":"case":this.sensitivity=t?"accent":"base",this.locale=n,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"})}compare(e,t){return this.collator.compare(e,t)}resolvedLocale(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale}}class Ae{constructor(e,t,n,a,i){this.text=e,this.image=t,this.scale=n,this.fontStack=a,this.textColor=i}}class D{constructor(e){this.sections=e}static fromString(e){return new D([new Ae(e,null,null,null,null)])}isEmpty(){return this.sections.length===0?!0:!this.sections.some(e=>e.text.length!==0||e.image&&e.image.name.length!==0)}static factory(e){return e instanceof D?e:D.fromString(e)}toString(){return this.sections.length===0?"":this.sections.map(e=>e.text).join("")}}class N{constructor(e){this.values=e.slice()}static parse(e){if(e instanceof N)return e;if(typeof e=="number")return new N([e,e,e,e]);if(Array.isArray(e)&&!(e.length<1||e.length>4)){for(const t of e)if(typeof t!="number")return;switch(e.length){case 1:e=[e[0],e[0],e[0],e[0]];break;case 2:e=[e[0],e[1],e[0],e[1]];break;case 3:e=[e[0],e[1],e[2],e[1]];break}return new N(e)}}toString(){return JSON.stringify(this.values)}}class F{constructor(e){this.name=e.name,this.available=e.available}toString(){return this.name}static fromString(e){return e?new F({name:e,available:!1}):null}}function zt(r,e,t,n){return typeof r=="number"&&r>=0&&r<=255&&typeof e=="number"&&e>=0&&e<=255&&typeof t=="number"&&t>=0&&t<=255?typeof n>"u"||typeof n=="number"&&n>=0&&n<=1?null:`Invalid rgba value [${[r,e,t,n].join(", ")}]: 'a' must be between 0 and 1.`:`Invalid rgba value [${(typeof n=="number"?[r,e,t,n]:[r,e,t]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`}function pe(r){if(r===null)return!0;if(typeof r=="string")return!0;if(typeof r=="boolean")return!0;if(typeof r=="number")return!0;if(r instanceof $)return!0;if(r instanceof Fe)return!0;if(r instanceof D)return!0;if(r instanceof N)return!0;if(r instanceof F)return!0;if(Array.isArray(r)){for(const e of r)if(!pe(e))return!1;return!0}else if(typeof r=="object"){for(const e in r)if(!pe(r[e]))return!1;return!0}else return!1}function T(r){if(r===null)return me;if(typeof r=="string")return y;if(typeof r=="boolean")return f;if(typeof r=="number")return p;if(r instanceof $)return A;if(r instanceof Fe)return ge;if(r instanceof D)return Ne;if(r instanceof N)return ze;if(r instanceof F)return be;if(Array.isArray(r)){const e=r.length;let t;for(const n of r){const a=T(n);if(!t)t=a;else{if(t===a)continue;t=h;break}}return I(t||h,e)}else return K}function Q(r){const e=typeof r;return r===null?"":e==="string"||e==="number"||e==="boolean"?String(r):r instanceof $||r instanceof D||r instanceof N||r instanceof F?r.toString():JSON.stringify(r)}class W{constructor(e,t){this.type=e,this.value=t}static parse(e,t){if(e.length!==2)return t.error(`'literal' expression requires exactly one argument, but found ${e.length-1} instead.`);if(!pe(e[1]))return t.error("invalid value");const n=e[1];let a=T(n);const i=t.expectedType;return a.kind==="array"&&a.N===0&&i&&i.kind==="array"&&(typeof i.N!="number"||i.N===0)&&(a=i),new W(a,n)}evaluate(){return this.value}eachChild(){}outputDefined(){return!0}}class S{constructor(e){this.name="ExpressionEvaluationError",this.message=e}toJSON(){return this.message}}const le={string:y,number:p,boolean:f,object:K};class E{constructor(e,t){this.type=e,this.args=t}static parse(e,t){if(e.length<2)return t.error("Expected at least one argument.");let n=1,a;const i=e[0];if(i==="array"){let o;if(e.length>2){const u=e[1];if(typeof u!="string"||!(u in le)||u==="object")return t.error('The item type argument of "array" must be one of string, number, boolean',1);o=le[u],n++}else o=h;let l;if(e.length>3){if(e[2]!==null&&(typeof e[2]!="number"||e[2]<0||e[2]!==Math.floor(e[2])))return t.error('The length argument to "array" must be a positive integer literal',2);l=e[2],n++}a=I(o,l)}else{if(!le[i])throw new Error(`Types doesn't contain name = ${i}`);a=le[i]}const s=[];for(;n<e.length;n++){const o=t.parse(e[n],n,h);if(!o)return null;s.push(o)}return new E(a,s)}evaluate(e){for(let t=0;t<this.args.length;t++){const n=this.args[t].evaluate(e);if(te(this.type,T(n))){if(t===this.args.length-1)throw new S(`Expected value to be of type ${b(this.type)}, but found ${b(T(n))} instead.`)}else return n}throw new Error}eachChild(e){this.args.forEach(e)}outputDefined(){return this.args.every(e=>e.outputDefined())}}const mt={"to-boolean":f,"to-color":A,"to-number":p,"to-string":y};class z{constructor(e,t){this.type=e,this.args=t}static parse(e,t){if(e.length<2)return t.error("Expected at least one argument.");const n=e[0];if(!mt[n])throw new Error(`Can't parse ${n} as it is not part of the known types`);if((n==="to-boolean"||n==="to-string")&&e.length!==2)return t.error("Expected one argument.");const a=mt[n],i=[];for(let s=1;s<e.length;s++){const o=t.parse(e[s],s,h);if(!o)return null;i.push(o)}return new z(a,i)}evaluate(e){if(this.type.kind==="boolean")return!!this.args[0].evaluate(e);if(this.type.kind==="color"){let t,n;for(const a of this.args){if(t=a.evaluate(e),n=null,t instanceof $)return t;if(typeof t=="string"){const i=e.parseColor(t);if(i)return i}else if(Array.isArray(t)&&(t.length<3||t.length>4?n=`Invalid rbga value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.`:n=zt(t[0],t[1],t[2],t[3]),!n))return new $(t[0]/255,t[1]/255,t[2]/255,t[3])}throw new S(n||`Could not parse color from value '${typeof t=="string"?t:JSON.stringify(t)}'`)}else if(this.type.kind==="padding"){let t;for(const n of this.args){t=n.evaluate(e);const a=N.parse(t);if(a)return a}throw new S(`Could not parse padding from value '${typeof t=="string"?t:JSON.stringify(t)}'`)}else if(this.type.kind==="number"){let t=null;for(const n of this.args){if(t=n.evaluate(e),t===null)return 0;const a=Number(t);if(!isNaN(a))return a}throw new S(`Could not convert ${JSON.stringify(t)} to number.`)}else return this.type.kind==="formatted"?D.fromString(Q(this.args[0].evaluate(e))):this.type.kind==="resolvedImage"?F.fromString(Q(this.args[0].evaluate(e))):Q(this.args[0].evaluate(e))}eachChild(e){this.args.forEach(e)}outputDefined(){return this.args.every(e=>e.outputDefined())}}const Zr=["Unknown","Point","LineString","Polygon"];class Br{constructor(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null,this.canonical=null}id(){return this.feature&&"id"in this.feature?this.feature.id:null}geometryType(){return this.feature?typeof this.feature.type=="number"?Zr[this.feature.type]:this.feature.type:null}geometry(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null}canonicalID(){return this.canonical}properties(){return this.feature&&this.feature.properties||{}}parseColor(e){let t=this._parseColorCache[e];return t||(t=this._parseColorCache[e]=$.parse(e)),t}}class Le{constructor(e,t,n=[],a,i=new Pe,s=[]){this.registry=e,this.path=n,this.key=n.map(o=>`[${o}]`).join(""),this.scope=i,this.errors=s,this.expectedType=a,this._isConstant=t}parse(e,t,n,a,i={}){return t?this.concat(t,n,a)._parse(e,i):this._parse(e,i)}_parse(e,t){(e===null||typeof e=="string"||typeof e=="boolean"||typeof e=="number")&&(e=["literal",e]);function n(a,i,s){return s==="assert"?new E(i,[a]):s==="coerce"?new z(i,[a]):a}if(Array.isArray(e)){if(e.length===0)return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');const a=e[0];if(typeof a!="string")return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use ["literal", [...]].`,0),null;const i=this.registry[a];if(i){let s=i.parse(e,this);if(!s)return null;if(this.expectedType){const o=this.expectedType,l=s.type;if((o.kind==="string"||o.kind==="number"||o.kind==="boolean"||o.kind==="object"||o.kind==="array")&&l.kind==="value")s=n(s,o,t.typeAnnotation||"assert");else if((o.kind==="color"||o.kind==="formatted"||o.kind==="resolvedImage")&&(l.kind==="value"||l.kind==="string"))s=n(s,o,t.typeAnnotation||"coerce");else if(o.kind==="padding"&&(l.kind==="value"||l.kind==="number"||l.kind==="array"))s=n(s,o,t.typeAnnotation||"coerce");else if(this.checkSubtype(o,l))return null}if(!(s instanceof W)&&s.type.kind!=="resolvedImage"&&this._isConstant(s)){const o=new Br;try{s=new W(s.type,s.evaluate(o))}catch(l){return this.error(l.message),null}}return s}return this.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`,0)}else return typeof e>"u"?this.error("'undefined' value invalid. Use null instead."):typeof e=="object"?this.error('Bare objects invalid. Use ["literal", {...}] instead.'):this.error(`Expected an array, but found ${typeof e} instead.`)}concat(e,t,n){const a=typeof e=="number"?this.path.concat(e):this.path,i=n?this.scope.concat(n):this.scope;return new Le(this.registry,this._isConstant,a,t||null,i,this.errors)}error(e,...t){const n=`${this.key}${t.map(a=>`[${a}]`).join("")}`;this.errors.push(new zr(n,e))}checkSubtype(e,t){const n=te(e,t);return n&&this.error(n),n}}class ve{constructor(e,t,n){this.type=ge,this.locale=n,this.caseSensitive=e,this.diacriticSensitive=t}static parse(e,t){if(e.length!==2)return t.error("Expected one argument.");const n=e[1];if(typeof n!="object"||Array.isArray(n))return t.error("Collator options argument must be an object.");const a=t.parse(n["case-sensitive"]===void 0?!1:n["case-sensitive"],1,f);if(!a)return null;const i=t.parse(n["diacritic-sensitive"]===void 0?!1:n["diacritic-sensitive"],1,f);if(!i)return null;let s=null;return n.locale&&(s=t.parse(n.locale,1,y),!s)?null:new ve(a,i,s)}evaluate(e){return new Fe(this.caseSensitive.evaluate(e),this.diacriticSensitive.evaluate(e),this.locale?this.locale.evaluate(e):null)}eachChild(e){e(this.caseSensitive),e(this.diacriticSensitive),this.locale&&e(this.locale)}outputDefined(){return!1}}const P=8192;function qe(r,e){r[0]=Math.min(r[0],e[0]),r[1]=Math.min(r[1],e[1]),r[2]=Math.max(r[2],e[0]),r[3]=Math.max(r[3],e[1])}function Yr(r){return(180+r)/360}function Qr(r){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+r*Math.PI/360)))/360}function ce(r,e){return!(r[0]<=e[0]||r[2]>=e[2]||r[1]<=e[1]||r[3]>=e[3])}function en(r,e){const t=Yr(r[0]),n=Qr(r[1]),a=Math.pow(2,e.z);return[Math.round(t*a*P),Math.round(n*a*P)]}function tn(r,e,t){const n=r[0]-e[0],a=r[1]-e[1],i=r[0]-t[0],s=r[1]-t[1];return n*s-i*a===0&&n*i<=0&&a*s<=0}function rn(r,e,t){return e[1]>r[1]!=t[1]>r[1]&&r[0]<(t[0]-e[0])*(r[1]-e[1])/(t[1]-e[1])+e[0]}function Ue(r,e){let t=!1;for(let n=0,a=e.length;n<a;n++){const i=e[n];for(let s=0,o=i.length;s<o-1;s++){if(tn(r,i[s],i[s+1]))return!1;rn(r,i[s],i[s+1])&&(t=!t)}}return t}function nn(r,e){for(let t=0;t<e.length;t++)if(Ue(r,e[t]))return!0;return!1}function an(r,e){return r[0]*e[1]-r[1]*e[0]}function gt(r,e,t,n){const a=r[0]-t[0],i=r[1]-t[1],s=e[0]-t[0],o=e[1]-t[1],l=n[0]-t[0],u=n[1]-t[1],c=a*u-l*i,d=s*u-l*o;return c>0&&d<0||c<0&&d>0}function sn(r,e,t,n){const a=[e[0]-r[0],e[1]-r[1]],i=[n[0]-t[0],n[1]-t[1]];return an(i,a)===0?!1:!!(gt(r,e,t,n)&&gt(t,n,r,e))}function on(r,e,t){for(const n of t)for(let a=0;a<n.length-1;++a)if(sn(r,e,n[a],n[a+1]))return!0;return!1}function Ot(r,e){for(let t=0;t<r.length;++t)if(!Ue(r[t],e))return!1;for(let t=0;t<r.length-1;++t)if(on(r[t],r[t+1],e))return!1;return!0}function ln(r,e){for(let t=0;t<e.length;t++)if(Ot(r,e[t]))return!0;return!1}function Re(r,e,t){const n=[];for(let a=0;a<r.length;a++){const i=[];for(let s=0;s<r[a].length;s++){const o=en(r[a][s],t);qe(e,o),i.push(o)}n.push(i)}return n}function Pt(r,e,t){const n=[];for(let a=0;a<r.length;a++){const i=Re(r[a],e,t);n.push(i)}return n}function Ft(r,e,t,n){if(r[0]<t[0]||r[0]>t[2]){const a=n*.5;let i=r[0]-t[0]>a?-n:t[0]-r[0]>a?n:0;i===0&&(i=r[0]-t[2]>a?-n:t[2]-r[0]>a?n:0),r[0]+=i}qe(e,r)}function un(r){r[0]=r[1]=1/0,r[2]=r[3]=-1/0}function bt(r,e,t,n){const a=Math.pow(2,n.z)*P,i=[n.x*P,n.y*P],s=[];for(const o of r)for(const l of o){const u=[l.x+i[0],l.y+i[1]];Ft(u,e,t,a),s.push(u)}return s}function vt(r,e,t,n){const a=Math.pow(2,n.z)*P,i=[n.x*P,n.y*P],s=[];for(const o of r){const l=[];for(const u of o){const c=[u.x+i[0],u.y+i[1]];qe(e,c),l.push(c)}s.push(l)}if(e[2]-e[0]<=a/2){un(e);for(const o of s)for(const l of o)Ft(l,e,t,a)}return s}function pn(r,e){const t=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],a=r.canonicalID();if(e.type==="Polygon"){const i=Re(e.coordinates,n,a),s=bt(r.geometry(),t,n,a);if(!ce(t,n))return!1;for(const o of s)if(!Ue(o,i))return!1}if(e.type==="MultiPolygon"){const i=Pt(e.coordinates,n,a),s=bt(r.geometry(),t,n,a);if(!ce(t,n))return!1;for(const o of s)if(!nn(o,i))return!1}return!0}function cn(r,e){const t=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],a=r.canonicalID();if(e.type==="Polygon"){const i=Re(e.coordinates,n,a),s=vt(r.geometry(),t,n,a);if(!ce(t,n))return!1;for(const o of s)if(!Ot(o,i))return!1}if(e.type==="MultiPolygon"){const i=Pt(e.coordinates,n,a),s=vt(r.geometry(),t,n,a);if(!ce(t,n))return!1;for(const o of s)if(!ln(o,i))return!1}return!0}class U{constructor(e,t){this.type=f,this.geojson=e,this.geometries=t}static parse(e,t){if(e.length!==2)return t.error(`'within' expression requires exactly one argument, but found ${e.length-1} instead.`);if(pe(e[1])){const n=e[1];if(n.type==="FeatureCollection")for(let a=0;a<n.features.length;++a){const i=n.features[a].geometry.type;if(i==="Polygon"||i==="MultiPolygon")return new U(n,n.features[a].geometry)}else if(n.type==="Feature"){const a=n.geometry.type;if(a==="Polygon"||a==="MultiPolygon")return new U(n,n.geometry)}else if(n.type==="Polygon"||n.type==="MultiPolygon")return new U(n,n)}return t.error("'within' expression requires valid geojson object that contains polygon geometry type.")}evaluate(e){if(e.geometry()!=null&&e.canonicalID()!=null){if(e.geometryType()==="Point")return pn(e,this.geometries);if(e.geometryType()==="LineString")return cn(e,this.geometries)}return!1}eachChild(){}outputDefined(){return!0}}class we{constructor(e,t){this.type=t.type,this.name=e,this.boundExpression=t}static parse(e,t){if(e.length!==2||typeof e[1]!="string")return t.error("'var' expression requires exactly one string literal argument.");const n=e[1];return t.scope.has(n)?new we(n,t.scope.get(n)):t.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`,1)}evaluate(e){return this.boundExpression.evaluate(e)}eachChild(){}outputDefined(){return!1}}class j{constructor(e,t,n,a){this.name=e,this.type=t,this._evaluate=n,this.args=a}evaluate(e){return this._evaluate(e,this.args)}eachChild(e){this.args.forEach(e)}outputDefined(){return!1}static parse(e,t){const n=e[0],a=j.definitions[n];if(!a)return t.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`,0);const i=Array.isArray(a)?a[0]:a.type,s=Array.isArray(a)?[[a[1],a[2]]]:a.overloads,o=s.filter(([u])=>!Array.isArray(u)||u.length===e.length-1);let l=null;for(const[u,c]of o){l=new Le(t.registry,De,t.path,null,t.scope);const d=[];let v=!1;for(let w=1;w<e.length;w++){const k=e[w],L=Array.isArray(u)?u[w-1]:u.type,R=l.parse(k,1+d.length,L);if(!R){v=!0;break}d.push(R)}if(!v){if(Array.isArray(u)&&u.length!==d.length){l.error(`Expected ${u.length} arguments, but found ${d.length} instead.`);continue}for(let w=0;w<d.length;w++){const k=Array.isArray(u)?u[w]:u.type,L=d[w];l.concat(w+1).checkSubtype(k,L.type)}if(l.errors.length===0)return new j(n,i,c,d)}}if(o.length===1)t.errors.push(...l.errors);else{const c=(o.length?o:s).map(([v])=>fn(v)).join(" | "),d=[];for(let v=1;v<e.length;v++){const w=t.parse(e[v],1+d.length);if(!w)return null;d.push(b(w.type))}t.error(`Expected arguments of type ${c}, but found (${d.join(", ")}) instead.`)}return null}static register(e,t){j.definitions=t;for(const n in t)e[n]=j}}function fn(r){return Array.isArray(r)?`(${r.map(b).join(", ")})`:`(${b(r.type)}...)`}function De(r){if(r instanceof we)return De(r.boundExpression);if(r instanceof j&&r.name==="error")return!1;if(r instanceof ve)return!1;if(r instanceof U)return!1;const e=r instanceof z||r instanceof E;let t=!0;return r.eachChild(n=>{e?t=t&&De(n):t=t&&n instanceof W}),t?Lt(r)&&qt(r,["zoom","heatmap-density","line-progress","accumulated","is-supported-script"]):!1}function Lt(r){if(r instanceof j){if(r.name==="get"&&r.args.length===1)return!1;if(r.name==="feature-state")return!1;if(r.name==="has"&&r.args.length===1)return!1;if(r.name==="properties"||r.name==="geometry-type"||r.name==="id")return!1;if(/^filter-/.test(r.name))return!1}if(r instanceof U)return!1;let e=!0;return r.eachChild(t=>{e&&!Lt(t)&&(e=!1)}),e}function qt(r,e){if(r instanceof j&&e.indexOf(r.name)>=0)return!1;let t=!0;return r.eachChild(n=>{t&&!qt(n,e)&&(t=!1)}),t}class He{constructor(e,t){this.type=t.type,this.bindings=[].concat(e),this.result=t}evaluate(e){return this.result.evaluate(e)}eachChild(e){for(const t of this.bindings)e(t[1]);e(this.result)}static parse(e,t){if(e.length<4)return t.error(`Expected at least 3 arguments, but found ${e.length-1} instead.`);const n=[];for(let i=1;i<e.length-1;i+=2){const s=e[i];if(typeof s!="string")return t.error(`Expected string, but found ${typeof s} instead.`,i);if(/[^a-zA-Z0-9_]/.test(s))return t.error("Variable names must contain only alphanumeric characters or '_'.",i);const o=t.parse(e[i+1],i+1);if(!o)return null;n.push([s,o])}const a=t.parse(e[e.length-1],e.length-1,t.expectedType,n);return a?new He(n,a):null}outputDefined(){return this.result.outputDefined()}}class Ve{constructor(e,t,n){this.type=e,this.index=t,this.input=n}static parse(e,t){if(e.length!==3)return t.error(`Expected 2 arguments, but found ${e.length-1} instead.`);const n=t.parse(e[1],1,p),a=t.parse(e[2],2,I(t.expectedType||h));if(!n||!a)return null;const i=a.type;return new Ve(i.itemType,n,a)}evaluate(e){const t=this.index.evaluate(e),n=this.input.evaluate(e);if(t<0)throw new S(`Array index out of bounds: ${t} < 0.`);if(t>=n.length)throw new S(`Array index out of bounds: ${t} > ${n.length-1}.`);if(t!==Math.floor(t))throw new S(`Array index must be an integer, but found ${t} instead.`);return n[t]}eachChild(e){e(this.index),e(this.input)}outputDefined(){return!1}}class Je{constructor(e,t){this.type=f,this.needle=e,this.haystack=t}static parse(e,t){if(e.length!==3)return t.error(`Expected 2 arguments, but found ${e.length-1} instead.`);const n=t.parse(e[1],1,h),a=t.parse(e[2],2,h);return!n||!a?null:Oe(n.type,[f,y,p,me,h])?new Je(n,a):t.error(`Expected first argument to be of type boolean, string, number or null, but found ${b(n.type)} instead`)}evaluate(e){const t=this.needle.evaluate(e),n=this.haystack.evaluate(e);if(!n)return!1;if(!re(t,["boolean","string","number","null"]))throw new S(`Expected first argument to be of type boolean, string, number or null, but found ${b(T(t))} instead.`);if(!re(n,["string","array"]))throw new S(`Expected second argument to be of type array or string, but found ${b(T(n))} instead.`);return n.indexOf(t)>=0}eachChild(e){e(this.needle),e(this.haystack)}outputDefined(){return!0}}class fe{constructor(e,t,n){this.type=p,this.needle=e,this.haystack=t,this.fromIndex=n}static parse(e,t){if(e.length<=2||e.length>=5)return t.error(`Expected 3 or 4 arguments, but found ${e.length-1} instead.`);const n=t.parse(e[1],1,h),a=t.parse(e[2],2,h);if(!n||!a)return null;if(!Oe(n.type,[f,y,p,me,h]))return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${b(n.type)} instead`);if(e.length===4){const i=t.parse(e[3],3,p);return i?new fe(n,a,i):null}else return new fe(n,a)}evaluate(e){const t=this.needle.evaluate(e),n=this.haystack.evaluate(e);if(!re(t,["boolean","string","number","null"]))throw new S(`Expected first argument to be of type boolean, string, number or null, but found ${b(T(t))} instead.`);if(!re(n,["string","array"]))throw new S(`Expected second argument to be of type array or string, but found ${b(T(n))} instead.`);if(this.fromIndex){const a=this.fromIndex.evaluate(e);return n.indexOf(t,a)}return n.indexOf(t)}eachChild(e){e(this.needle),e(this.haystack),this.fromIndex&&e(this.fromIndex)}outputDefined(){return!1}}class Ke{constructor(e,t,n,a,i,s){this.inputType=e,this.type=t,this.input=n,this.cases=a,this.outputs=i,this.otherwise=s}static parse(e,t){if(e.length<5)return t.error(`Expected at least 4 arguments, but found only ${e.length-1}.`);if(e.length%2!==1)return t.error("Expected an even number of arguments.");let n,a;t.expectedType&&t.expectedType.kind!=="value"&&(a=t.expectedType);const i={},s=[];for(let u=2;u<e.length-1;u+=2){let c=e[u];const d=e[u+1];Array.isArray(c)||(c=[c]);const v=t.concat(u);if(c.length===0)return v.error("Expected at least one branch label.");for(const k of c){if(typeof k!="number"&&typeof k!="string")return v.error("Branch labels must be numbers or strings.");if(typeof k=="number"&&Math.abs(k)>Number.MAX_SAFE_INTEGER)return v.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);if(typeof k=="number"&&Math.floor(k)!==k)return v.error("Numeric branch labels must be integer values.");if(!n)n=T(k);else if(v.checkSubtype(n,T(k)))return null;if(typeof i[String(k)]<"u")return v.error("Branch labels must be unique.");i[String(k)]=s.length}const w=t.parse(d,u,a);if(!w)return null;a=a||w.type,s.push(w)}const o=t.parse(e[1],1,h);if(!o)return null;const l=t.parse(e[e.length-1],e.length-1,a);return!l||o.type.kind!=="value"&&t.concat(1).checkSubtype(n,o.type)?null:new Ke(n,a,o,i,s,l)}evaluate(e){const t=this.input.evaluate(e);return(T(t)===this.inputType&&this.outputs[this.cases[t]]||this.otherwise).evaluate(e)}eachChild(e){e(this.input),this.outputs.forEach(e),e(this.otherwise)}outputDefined(){return this.outputs.every(e=>e.outputDefined())&&this.otherwise.outputDefined()}}class Xe{constructor(e,t,n){this.type=e,this.branches=t,this.otherwise=n}static parse(e,t){if(e.length<4)return t.error(`Expected at least 3 arguments, but found only ${e.length-1}.`);if(e.length%2!==0)return t.error("Expected an odd number of arguments.");let n;t.expectedType&&t.expectedType.kind!=="value"&&(n=t.expectedType);const a=[];for(let s=1;s<e.length-1;s+=2){const o=t.parse(e[s],s,f);if(!o)return null;const l=t.parse(e[s+1],s+1,n);if(!l)return null;a.push([o,l]),n=n||l.type}const i=t.parse(e[e.length-1],e.length-1,n);if(!i)return null;if(!n)throw new Error("Can't infer output type");return new Xe(n,a,i)}evaluate(e){for(const[t,n]of this.branches)if(t.evaluate(e))return n.evaluate(e);return this.otherwise.evaluate(e)}eachChild(e){for(const[t,n]of this.branches)e(t),e(n);e(this.otherwise)}outputDefined(){return this.branches.every(([e,t])=>t.outputDefined())&&this.otherwise.outputDefined()}}class he{constructor(e,t,n,a){this.type=e,this.input=t,this.beginIndex=n,this.endIndex=a}static parse(e,t){if(e.length<=2||e.length>=5)return t.error(`Expected 3 or 4 arguments, but found ${e.length-1} instead.`);const n=t.parse(e[1],1,h),a=t.parse(e[2],2,p);if(!n||!a)return null;if(!Oe(n.type,[I(h),y,h]))return t.error(`Expected first argument to be of type array or string, but found ${b(n.type)} instead`);if(e.length===4){const i=t.parse(e[3],3,p);return i?new he(n.type,n,a,i):null}else return new he(n.type,n,a)}evaluate(e){const t=this.input.evaluate(e),n=this.beginIndex.evaluate(e);if(!re(t,["string","array"]))throw new S(`Expected first argument to be of type array or string, but found ${b(T(t))} instead.`);if(this.endIndex){const a=this.endIndex.evaluate(e);return t.slice(n,a)}return t.slice(n)}eachChild(e){e(this.input),e(this.beginIndex),this.endIndex&&e(this.endIndex)}outputDefined(){return!1}}function Ut(r,e){const t=r.length-1;let n=0,a=t,i=0,s,o;for(;n<=a;)if(i=Math.floor((n+a)/2),s=r[i],o=r[i+1],s<=e){if(i===t||e<o)return i;n=i+1}else if(s>e)a=i-1;else throw new S("Input is not a number.");return 0}class Ge{constructor(e,t,n){this.type=e,this.input=t,this.labels=[],this.outputs=[];for(const[a,i]of n)this.labels.push(a),this.outputs.push(i)}static parse(e,t){if(e.length-1<4)return t.error(`Expected at least 4 arguments, but found only ${e.length-1}.`);if((e.length-1)%2!==0)return t.error("Expected an even number of arguments.");const n=t.parse(e[1],1,p);if(!n)return null;const a=[];let i=null;t.expectedType&&t.expectedType.kind!=="value"&&(i=t.expectedType);for(let s=1;s<e.length;s+=2){const o=s===1?-1/0:e[s],l=e[s+1],u=s,c=s+1;if(typeof o!="number")return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',u);if(a.length&&a[a.length-1][0]>=o)return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',u);const d=t.parse(l,c,i);if(!d)return null;i=i||d.type,a.push([o,d])}return new Ge(i,n,a)}evaluate(e){const t=this.labels,n=this.outputs;if(t.length===1)return n[0].evaluate(e);const a=this.input.evaluate(e);if(a<=t[0])return n[0].evaluate(e);const i=t.length;if(a>=t[i-1])return n[i-1].evaluate(e);const s=Ut(t,a);return n[s].evaluate(e)}eachChild(e){e(this.input);for(const t of this.outputs)e(t)}outputDefined(){return this.outputs.every(e=>e.outputDefined())}}var hn=Rt;function Rt(r,e,t,n){this.cx=3*r,this.bx=3*(t-r)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*e,this.by=3*(n-e)-this.cy,this.ay=1-this.cy-this.by,this.p1x=r,this.p1y=e,this.p2x=t,this.p2y=n}Rt.prototype={sampleCurveX:function(r){return((this.ax*r+this.bx)*r+this.cx)*r},sampleCurveY:function(r){return((this.ay*r+this.by)*r+this.cy)*r},sampleCurveDerivativeX:function(r){return(3*this.ax*r+2*this.bx)*r+this.cx},solveCurveX:function(r,e){if(e===void 0&&(e=1e-6),r<0)return 0;if(r>1)return 1;for(var t=r,n=0;n<8;n++){var a=this.sampleCurveX(t)-r;if(Math.abs(a)<e)return t;var i=this.sampleCurveDerivativeX(t);if(Math.abs(i)<1e-6)break;t=t-a/i}var s=0,o=1;for(t=r,n=0;n<20&&(a=this.sampleCurveX(t),!(Math.abs(a-r)<e));n++)r>a?s=t:o=t,t=(o-s)*.5+s;return t},solve:function(r,e){return this.sampleCurveY(this.solveCurveX(r,e))}};function ee(r,e,t){return r+t*(e-r)}function yn(r,e,t,n="rgb"){switch(n){case"rgb":{const[a,i,s,o]=ye(r.rgb,e.rgb,t);return new $(a,i,s,o,!1)}case"hcl":{const[a,i,s,o]=r.hcl,[l,u,c,d]=e.hcl;let v,w;if(!isNaN(a)&&!isNaN(l)){let H=l-a;l>a&&H>180?H-=360:l<a&&a-l>180&&(H+=360),v=a+t*H}else isNaN(a)?isNaN(l)?v=NaN:(v=l,(s===1||s===0)&&(w=u)):(v=a,(c===1||c===0)&&(w=i));const[k,L,R,ie]=Xr([v,w??ee(i,u,t),ee(s,c,t),ee(o,d,t)]);return new $(k,L,R,ie,!1)}case"lab":{const[a,i,s,o]=Nt(ye(r.lab,e.lab,t));return new $(a,i,s,o,!1)}}}function ye(r,e,t){return r.map((n,a)=>ee(n,e[a],t))}function dn(r,e,t){return new N(ye(r.values,e.values,t))}const _e={number:ee,color:yn,array:ye,padding:dn};class G{constructor(e,t,n,a,i){this.type=e,this.operator=t,this.interpolation=n,this.input=a,this.labels=[],this.outputs=[];for(const[s,o]of i)this.labels.push(s),this.outputs.push(o)}static interpolationFactor(e,t,n,a){let i=0;if(e.name==="exponential")i=Ie(t,e.base,n,a);else if(e.name==="linear")i=Ie(t,1,n,a);else if(e.name==="cubic-bezier"){const s=e.controlPoints;i=new hn(s[0],s[1],s[2],s[3]).solve(Ie(t,1,n,a))}return i}static parse(e,t){let[n,a,i,...s]=e;if(!Array.isArray(a)||a.length===0)return t.error("Expected an interpolation type expression.",1);if(a[0]==="linear")a={name:"linear"};else if(a[0]==="exponential"){const u=a[1];if(typeof u!="number")return t.error("Exponential interpolation requires a numeric base.",1,1);a={name:"exponential",base:u}}else if(a[0]==="cubic-bezier"){const u=a.slice(1);if(u.length!==4||u.some(c=>typeof c!="number"||c<0||c>1))return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);a={name:"cubic-bezier",controlPoints:u}}else return t.error(`Unknown interpolation type ${String(a[0])}`,1,0);if(e.length-1<4)return t.error(`Expected at least 4 arguments, but found only ${e.length-1}.`);if((e.length-1)%2!==0)return t.error("Expected an even number of arguments.");if(i=t.parse(i,2,p),!i)return null;const o=[];let l=null;n==="interpolate-hcl"||n==="interpolate-lab"?l=A:t.expectedType&&t.expectedType.kind!=="value"&&(l=t.expectedType);for(let u=0;u<s.length;u+=2){const c=s[u],d=s[u+1],v=u+3,w=u+4;if(typeof c!="number")return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',v);if(o.length&&o[o.length-1][0]>=c)return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',v);const k=t.parse(d,w,l);if(!k)return null;l=l||k.type,o.push([c,k])}return!se(l,p)&&!se(l,A)&&!se(l,ze)&&!se(l,I(p))?t.error(`Type ${b(l)} is not interpolatable.`):new G(l,n,a,i,o)}evaluate(e){const t=this.labels,n=this.outputs;if(t.length===1)return n[0].evaluate(e);const a=this.input.evaluate(e);if(a<=t[0])return n[0].evaluate(e);const i=t.length;if(a>=t[i-1])return n[i-1].evaluate(e);const s=Ut(t,a),o=t[s],l=t[s+1],u=G.interpolationFactor(this.interpolation,a,o,l),c=n[s].evaluate(e),d=n[s+1].evaluate(e);switch(this.operator){case"interpolate":return _e[this.type.kind](c,d,u);case"interpolate-hcl":return _e.color(c,d,u,"hcl");case"interpolate-lab":return _e.color(c,d,u,"lab")}}eachChild(e){e(this.input);for(const t of this.outputs)e(t)}outputDefined(){return this.outputs.every(e=>e.outputDefined())}}function Ie(r,e,t,n){const a=n-t,i=r-t;return a===0?0:e===1?i/a:(Math.pow(e,i)-1)/(Math.pow(e,a)-1)}class de{constructor(e,t){this.type=e,this.args=t}static parse(e,t){if(e.length<2)return t.error("Expectected at least one argument.");let n=null;const a=t.expectedType;a&&a.kind!=="value"&&(n=a);const i=[];for(const o of e.slice(1)){const l=t.parse(o,1+i.length,n,void 0,{typeAnnotation:"omit"});if(!l)return null;n=n||l.type,i.push(l)}if(!n)throw new Error("No output type");return a&&i.some(o=>te(a,o.type))?new de(h,i):new de(n,i)}evaluate(e){let t=null,n=0,a;for(const i of this.args)if(n++,t=i.evaluate(e),t&&t instanceof F&&!t.available&&(a||(a=t.name),t=null,n===this.args.length&&(t=a)),t!==null)break;return t}eachChild(e){this.args.forEach(e)}outputDefined(){return this.args.every(e=>e.outputDefined())}}function wt(r,e){return r==="=="||r==="!="?e.kind==="boolean"||e.kind==="string"||e.kind==="number"||e.kind==="null"||e.kind==="value":e.kind==="string"||e.kind==="number"||e.kind==="value"}function mn(r,e,t){return e===t}function gn(r,e,t){return e!==t}function bn(r,e,t){return e<t}function vn(r,e,t){return e>t}function wn(r,e,t){return e<=t}function kn(r,e,t){return e>=t}function Ht(r,e,t,n){return n.compare(e,t)===0}function xn(r,e,t,n){return!Ht(r,e,t,n)}function $n(r,e,t,n){return n.compare(e,t)<0}function Tn(r,e,t,n){return n.compare(e,t)>0}function Sn(r,e,t,n){return n.compare(e,t)<=0}function Cn(r,e,t,n){return n.compare(e,t)>=0}function B(r,e,t){const n=r!=="=="&&r!=="!=";return class Vt{constructor(i,s,o){this.type=f,this.lhs=i,this.rhs=s,this.collator=o,this.hasUntypedArgument=i.type.kind==="value"||s.type.kind==="value"}static parse(i,s){if(i.length!==3&&i.length!==4)return s.error("Expected two or three arguments.");const o=i[0];let l=s.parse(i[1],1,h);if(!l)return null;if(!wt(o,l.type))return s.concat(1).error(`"${o}" comparisons are not supported for type '${b(l.type)}'.`);let u=s.parse(i[2],2,h);if(!u)return null;if(!wt(o,u.type))return s.concat(2).error(`"${o}" comparisons are not supported for type '${b(u.type)}'.`);if(l.type.kind!==u.type.kind&&l.type.kind!=="value"&&u.type.kind!=="value")return s.error(`Cannot compare types '${b(l.type)}' and '${b(u.type)}'.`);n&&(l.type.kind==="value"&&u.type.kind!=="value"?l=new E(u.type,[l]):l.type.kind!=="value"&&u.type.kind==="value"&&(u=new E(l.type,[u])));let c=null;if(i.length===4){if(l.type.kind!=="string"&&u.type.kind!=="string"&&l.type.kind!=="value"&&u.type.kind!=="value")return s.error("Cannot use collator to compare non-string types.");if(c=s.parse(i[3],3,ge),!c)return null}return new Vt(l,u,c)}evaluate(i){const s=this.lhs.evaluate(i),o=this.rhs.evaluate(i);if(n&&this.hasUntypedArgument){const l=T(s),u=T(o);if(l.kind!==u.kind||!(l.kind==="string"||l.kind==="number"))throw new S(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`)}if(this.collator&&!n&&this.hasUntypedArgument){const l=T(s),u=T(o);if(l.kind!=="string"||u.kind!=="string")return e(i,s,o)}return this.collator?t(i,s,o,this.collator.evaluate(i)):e(i,s,o)}eachChild(i){i(this.lhs),i(this.rhs),this.collator&&i(this.collator)}outputDefined(){return!0}}}const _n=B("==",mn,Ht),In=B("!=",gn,xn),Mn=B("<",bn,$n),En=B(">",vn,Tn),jn=B("<=",wn,Sn),An=B(">=",kn,Cn);class We{constructor(e,t,n,a,i){this.type=y,this.number=e,this.locale=t,this.currency=n,this.minFractionDigits=a,this.maxFractionDigits=i}static parse(e,t){if(e.length!==3)return t.error("Expected two arguments.");const n=t.parse(e[1],1,p);if(!n)return null;const a=e[2];if(typeof a!="object"||Array.isArray(a))return t.error("NumberFormat options argument must be an object.");let i=null;if(a.locale&&(i=t.parse(a.locale,1,y),!i))return null;let s=null;if(a.currency&&(s=t.parse(a.currency,1,y),!s))return null;let o=null;if(a["min-fraction-digits"]&&(o=t.parse(a["min-fraction-digits"],1,p),!o))return null;let l=null;return a["max-fraction-digits"]&&(l=t.parse(a["max-fraction-digits"],1,p),!l)?null:new We(n,i,s,o,l)}evaluate(e){return new Intl.NumberFormat(this.locale?this.locale.evaluate(e):[],{style:this.currency?"currency":"decimal",currency:this.currency?this.currency.evaluate(e):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(e):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(e):void 0}).format(this.number.evaluate(e))}eachChild(e){e(this.number),this.locale&&e(this.locale),this.currency&&e(this.currency),this.minFractionDigits&&e(this.minFractionDigits),this.maxFractionDigits&&e(this.maxFractionDigits)}outputDefined(){return!1}}class Ze{constructor(e){this.type=Ne,this.sections=e}static parse(e,t){if(e.length<2)return t.error("Expected at least one argument.");const n=e[1];if(!Array.isArray(n)&&typeof n=="object")return t.error("First argument must be an image or text section.");const a=[];let i=!1;for(let s=1;s<=e.length-1;++s){const o=e[s];if(i&&typeof o=="object"&&!Array.isArray(o)){i=!1;let l=null;if(o["font-scale"]&&(l=t.parse(o["font-scale"],1,p),!l))return null;let u=null;if(o["text-font"]&&(u=t.parse(o["text-font"],1,I(y)),!u))return null;let c=null;if(o["text-color"]&&(c=t.parse(o["text-color"],1,A),!c))return null;const d=a[a.length-1];d.scale=l,d.font=u,d.textColor=c}else{const l=t.parse(e[s],1,h);if(!l)return null;const u=l.type.kind;if(u!=="string"&&u!=="value"&&u!=="null"&&u!=="resolvedImage")return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");i=!0,a.push({content:l,scale:null,font:null,textColor:null})}}return new Ze(a)}evaluate(e){const t=n=>{const a=n.content.evaluate(e);return T(a)===be?new Ae("",a,null,null,null):new Ae(Q(a),null,n.scale?n.scale.evaluate(e):null,n.font?n.font.evaluate(e).join(","):null,n.textColor?n.textColor.evaluate(e):null)};return new D(this.sections.map(t))}eachChild(e){for(const t of this.sections)e(t.content),t.scale&&e(t.scale),t.font&&e(t.font),t.textColor&&e(t.textColor)}outputDefined(){return!1}}class Be{constructor(e){this.type=be,this.input=e}static parse(e,t){if(e.length!==2)return t.error("Expected two arguments.");const n=t.parse(e[1],1,y);return n?new Be(n):t.error("No image name provided.")}evaluate(e){const t=this.input.evaluate(e),n=F.fromString(t);return n&&e.availableImages&&(n.available=e.availableImages.indexOf(t)>-1),n}eachChild(e){e(this.input)}outputDefined(){return!1}}class Ye{constructor(e){this.type=p,this.input=e}static parse(e,t){if(e.length!==2)return t.error(`Expected 1 argument, but found ${e.length-1} instead.`);const n=t.parse(e[1],1);return n?n.type.kind!=="array"&&n.type.kind!=="string"&&n.type.kind!=="value"?t.error(`Expected argument of type string or array, but found ${b(n.type)} instead.`):new Ye(n):null}evaluate(e){const t=this.input.evaluate(e);if(typeof t=="string")return t.length;if(Array.isArray(t))return t.length;throw new S(`Expected value to be of type string or array, but found ${b(T(t))} instead.`)}eachChild(e){e(this.input)}outputDefined(){return!1}}const Dn={"==":_n,"!=":In,">":En,"<":Mn,">=":An,"<=":jn,array:E,at:Ve,boolean:E,case:Xe,coalesce:de,collator:ve,format:Ze,image:Be,in:Je,"index-of":fe,interpolate:G,"interpolate-hcl":G,"interpolate-lab":G,length:Ye,let:He,literal:W,match:Ke,number:E,"number-format":We,object:E,slice:he,step:Ge,string:E,"to-boolean":z,"to-color":z,"to-number":z,"to-string":z,var:we,within:U};function kt(r,[e,t,n,a]){e=e.evaluate(r),t=t.evaluate(r),n=n.evaluate(r);const i=a?a.evaluate(r):1,s=zt(e,t,n,i);if(s)throw new S(s);return new $(e/255,t/255,n/255,i,!1)}function xt(r,e){return r in e}function Me(r,e){const t=e[r];return typeof t>"u"?null:t}function Nn(r,e,t,n){for(;t<=n;){const a=t+n>>1;if(e[a]===r)return!0;e[a]>r?n=a-1:t=a+1}return!1}function q(r){return{type:r}}j.register(Dn,{error:[Dr,[y],(r,[e])=>{throw new S(e.evaluate(r))}],typeof:[y,[h],(r,[e])=>b(T(e.evaluate(r)))],"to-rgba":[I(p,4),[A],(r,[e])=>{const[t,n,a,i]=e.evaluate(r).rgb;return[t*255,n*255,a*255,i]}],rgb:[A,[p,p,p],kt],rgba:[A,[p,p,p,p],kt],has:{type:f,overloads:[[[y],(r,[e])=>xt(e.evaluate(r),r.properties())],[[y,K],(r,[e,t])=>xt(e.evaluate(r),t.evaluate(r))]]},get:{type:h,overloads:[[[y],(r,[e])=>Me(e.evaluate(r),r.properties())],[[y,K],(r,[e,t])=>Me(e.evaluate(r),t.evaluate(r))]]},"feature-state":[h,[y],(r,[e])=>Me(e.evaluate(r),r.featureState||{})],properties:[K,[],r=>r.properties()],"geometry-type":[y,[],r=>r.geometryType()],id:[h,[],r=>r.id()],zoom:[p,[],r=>r.globals.zoom],"heatmap-density":[p,[],r=>r.globals.heatmapDensity||0],"line-progress":[p,[],r=>r.globals.lineProgress||0],accumulated:[h,[],r=>r.globals.accumulated===void 0?null:r.globals.accumulated],"+":[p,q(p),(r,e)=>{let t=0;for(const n of e)t+=n.evaluate(r);return t}],"*":[p,q(p),(r,e)=>{let t=1;for(const n of e)t*=n.evaluate(r);return t}],"-":{type:p,overloads:[[[p,p],(r,[e,t])=>e.evaluate(r)-t.evaluate(r)],[[p],(r,[e])=>-e.evaluate(r)]]},"/":[p,[p,p],(r,[e,t])=>e.evaluate(r)/t.evaluate(r)],"%":[p,[p,p],(r,[e,t])=>e.evaluate(r)%t.evaluate(r)],ln2:[p,[],()=>Math.LN2],pi:[p,[],()=>Math.PI],e:[p,[],()=>Math.E],"^":[p,[p,p],(r,[e,t])=>Math.pow(e.evaluate(r),t.evaluate(r))],sqrt:[p,[p],(r,[e])=>Math.sqrt(e.evaluate(r))],log10:[p,[p],(r,[e])=>Math.log(e.evaluate(r))/Math.LN10],ln:[p,[p],(r,[e])=>Math.log(e.evaluate(r))],log2:[p,[p],(r,[e])=>Math.log(e.evaluate(r))/Math.LN2],sin:[p,[p],(r,[e])=>Math.sin(e.evaluate(r))],cos:[p,[p],(r,[e])=>Math.cos(e.evaluate(r))],tan:[p,[p],(r,[e])=>Math.tan(e.evaluate(r))],asin:[p,[p],(r,[e])=>Math.asin(e.evaluate(r))],acos:[p,[p],(r,[e])=>Math.acos(e.evaluate(r))],atan:[p,[p],(r,[e])=>Math.atan(e.evaluate(r))],min:[p,q(p),(r,e)=>Math.min(...e.map(t=>t.evaluate(r)))],max:[p,q(p),(r,e)=>Math.max(...e.map(t=>t.evaluate(r)))],abs:[p,[p],(r,[e])=>Math.abs(e.evaluate(r))],round:[p,[p],(r,[e])=>{const t=e.evaluate(r);return t<0?-Math.round(-t):Math.round(t)}],floor:[p,[p],(r,[e])=>Math.floor(e.evaluate(r))],ceil:[p,[p],(r,[e])=>Math.ceil(e.evaluate(r))],"filter-==":[f,[y,h],(r,[e,t])=>r.properties()[e.value]===t.value],"filter-id-==":[f,[h],(r,[e])=>r.id()===e.value],"filter-type-==":[f,[y],(r,[e])=>r.geometryType()===e.value],"filter-<":[f,[y,h],(r,[e,t])=>{const n=r.properties()[e.value],a=t.value;return typeof n==typeof a&&n<a}],"filter-id-<":[f,[h],(r,[e])=>{const t=r.id(),n=e.value;return typeof t==typeof n&&t<n}],"filter->":[f,[y,h],(r,[e,t])=>{const n=r.properties()[e.value],a=t.value;return typeof n==typeof a&&n>a}],"filter-id->":[f,[h],(r,[e])=>{const t=r.id(),n=e.value;return typeof t==typeof n&&t>n}],"filter-<=":[f,[y,h],(r,[e,t])=>{const n=r.properties()[e.value],a=t.value;return typeof n==typeof a&&n<=a}],"filter-id-<=":[f,[h],(r,[e])=>{const t=r.id(),n=e.value;return typeof t==typeof n&&t<=n}],"filter->=":[f,[y,h],(r,[e,t])=>{const n=r.properties()[e.value],a=t.value;return typeof n==typeof a&&n>=a}],"filter-id->=":[f,[h],(r,[e])=>{const t=r.id(),n=e.value;return typeof t==typeof n&&t>=n}],"filter-has":[f,[h],(r,[e])=>e.value in r.properties()],"filter-has-id":[f,[],r=>r.id()!==null&&r.id()!==void 0],"filter-type-in":[f,[I(y)],(r,[e])=>e.value.indexOf(r.geometryType())>=0],"filter-id-in":[f,[I(h)],(r,[e])=>e.value.indexOf(r.id())>=0],"filter-in-small":[f,[y,I(h)],(r,[e,t])=>t.value.indexOf(r.properties()[e.value])>=0],"filter-in-large":[f,[y,I(h)],(r,[e,t])=>Nn(r.properties()[e.value],t.value,0,t.value.length-1)],all:{type:f,overloads:[[[f,f],(r,[e,t])=>e.evaluate(r)&&t.evaluate(r)],[q(f),(r,e)=>{for(const t of e)if(!t.evaluate(r))return!1;return!0}]]},any:{type:f,overloads:[[[f,f],(r,[e,t])=>e.evaluate(r)||t.evaluate(r)],[q(f),(r,e)=>{for(const t of e)if(t.evaluate(r))return!0;return!1}]]},"!":[f,[f],(r,[e])=>!e.evaluate(r)],"is-supported-script":[f,[y],(r,[e])=>{const t=r.globals&&r.globals.isSupportedScript;return t?t(e.evaluate(r)):!0}],upcase:[y,[y],(r,[e])=>e.evaluate(r).toUpperCase()],downcase:[y,[y],(r,[e])=>e.evaluate(r).toLowerCase()],concat:[y,q(h),(r,e)=>e.map(t=>Q(t.evaluate(r))).join("")],"resolved-locale":[y,[ge],(r,[e])=>e.evaluate(r).resolvedLocale()]});const V=[{type:"boolean",parameters:["value","value"]},{type:"boolean",parameters:["value","value","collator"]}],ne={"==":V,"!=":V,"<":V,"<=":V,">":V,">=":V,string:[{type:"string",parameters:["value"]},{type:"string",parameters:["value",{repeat:["fallback: value"]}]}],number:[{type:"number",parameters:["value"]},{type:"number",parameters:["value",{repeat:["fallback: value"]}]}],boolean:[{type:"boolean",parameters:["value"]},{type:"boolean",parameters:["value",{repeat:["fallback: value"]}]}],array:[{type:"array",parameters:["value"]},{type:"array<type>",parameters:['type: "string" | "number" | "boolean"',"value"]},{type:"array<type, N>",parameters:['type: "string" | "number" | "boolean"',"N: number (literal)","value"]}],image:[{type:"image",parameters:["value"]}],object:[{type:"object",parameters:["value"]},{type:"object",parameters:["value",{repeat:["fallback: value"]}]}],"to-boolean":[{type:"boolean",parameters:["value"]}],"to-color":[{type:"color",parameters:["value",{repeat:["fallback: value"]}]}],"to-number":[{type:"number",parameters:["value",{repeat:["fallback: value"]}]}],"to-string":[{type:"string",parameters:["value"]}],at:[{type:"ItemType",parameters:["number","array"]}],in:[{type:"boolean",parameters:["keyword: InputType (boolean, string, or number)","input: InputType (array or string)"]}],"index-of":[{type:"number",parameters:["keyword: InputType (boolean, string, or number)","input: InputType (array or string)"]},{type:"number",parameters:["keyword: InputType (boolean, string, or number)","input: InputType (array or string)","index: number"]}],slice:[{type:"OutputType (ItemType or string)",parameters:["input: InputType (array or string)","index: number"]},{type:"OutputType (ItemType or string)",parameters:["input: InputType (array or string)","index: number","index: number"]}],case:[{type:"OutputType",parameters:["condition: boolean, output: OutputType","condition: boolean, output: OutputType","...","fallback: OutputType"]}],coalesce:[{type:"OutputType",parameters:[{repeat:["OutputType"]}]}],step:[{type:"OutputType",parameters:["input: number","stop_output_0: OutputType","stop_input_1: number, stop_output_1: OutputType","stop_input_n: number, stop_output_n: OutputType, ..."]}],interpolate:[{type:"OutputType (number, array<number>, or Color)",parameters:['interpolation: ["linear"] | ["exponential", base] | ["cubic-bezier", x1, y1, x2, y2]',"input: number","stop_input_1: number, stop_output_1: OutputType","stop_input_n: number, stop_output_n: OutputType, ..."]}],"interpolate-hcl":[{type:"Color",parameters:['interpolation: ["linear"] | ["exponential", base] | ["cubic-bezier", x1, y1, x2, y2]',"input: number","stop_input_1: number, stop_output_1: Color","stop_input_n: number, stop_output_n: Color, ..."]}],"interpolate-lab":[{type:"Color",parameters:['interpolation: ["linear"] | ["exponential", base] | ["cubic-bezier", x1, y1, x2, y2 ]',"input: number","stop_input_1: number, stop_output_1: Color","stop_input_n: number, stop_output_n: Color, ..."]}],length:[{type:"number",parameters:["string | array | value"]}],let:[{type:"OutputType",parameters:[{repeat:["string (alphanumeric literal)","any"]},"OutputType"]}],literal:[{type:"array<T, N>",parameters:["[...] (JSON array literal)"]},{type:"object",parameters:["{...} (JSON object literal)"]}],match:[{type:"OutputType",parameters:["input: InputType (number or string)","label: InputType | [InputType, InputType, ...], output: OutputType","label: InputType | [InputType, InputType, ...], output: OutputType","...","fallback: OutputType"]}],var:[{type:"the type of the bound expression",parameters:["previously bound variable name"]}],within:[{type:"boolean",parameters:["object"]}],distance:[{type:"number",parameters:["object"]}],collator:[{type:"collator",parameters:['{ "case-sensitive": boolean, "diacritic-sensitive": boolean, "locale": string }']}],format:[{type:"formatted",parameters:['input_1: string | image, options_1: { "font-scale": number, "text-font": array<string>, "text-color": color }',"...",'input_n: string | image, options_n: { "font-scale": number, "text-font": array<string>, "text-color": color }']}],"number-format":[{type:"string",parameters:["input: number",'options: { "locale": string, "currency": string, "min-fraction-digits": number, "max-fraction-digits": number }']}]};for(const r in j.definitions){if(/^filter-/.test(r))continue;const e=j.definitions[r];Array.isArray(e)?ne[r]=[{type:b(e[0]),parameters:$t(e[1])}]:ne[r]=e.overloads.map(t=>({type:b(e.type),parameters:$t(t[0])}))}delete ne.error;function $t(r){return Array.isArray(r)?r.map(b):[{repeat:[b(r.type)]}]}const Jt={},ue={};for(const r in ne){const e=Er.expression_name.values[r];ue[e.group]=ue[e.group]||[],ue[e.group].push(r),Jt[r]={name:r,doc:e.doc,type:ne[r],sdkSupport:e["sdk-support"]}}const zn=["Types","Feature data","Lookup","Decision","Ramps, scales, curves","Variable binding","String","Color","Math","Zoom","Heatmap"].map(r=>({name:r,expressions:ue[r].sort((e,t)=>e.localeCompare(t)).map(e=>Jt[e])}));function Kt(r,e){const t=[""];for(const a of r)if(typeof a=="string")t.push(a);else if(a.repeat){const i=Kt(a.repeat,1/0);t.push(`${i.slice(2)}${i}, ...`)}const n=t.reduce((a,i)=>a+i.length+2,0);return!e||n<=e?t.join(", "):`${t.join(`,
    `)}
`}function On(r,e){r=JSON.stringify(r);const t=80-r.length-e.type.length,n=Kt(e.parameters,t);return`[${r}${n}]: ${e.type}`}const Pn=[{title:"Display HTML clusters with custom properties",href:"https://maplibre.org/maplibre-gl-js-docs/example/cluster-html/"}],Fn=[{title:"Create a hover effect",href:"https://maplibre.org/maplibre-gl-js-docs/example/hover-styles/"}],Ln=[{title:"Use a fallback image",href:"https://maplibre.org/maplibre-gl-js-docs/example/fallback-image/"}],qn=[{title:"Add a generated icon to the map",href:"https://maplibre.org/maplibre-gl-js-docs/example/add-image-missing-generated/"},{title:"Create a time slider",href:"https://maplibre.org/maplibre-gl-js-docs/example/timeline-animation/"},{title:"Use a fallback image",href:"https://maplibre.org/maplibre-gl-js-docs/example/fallback-image/"},{title:"Variable label placement",href:"https://maplibre.org/maplibre-gl-js-docs/example/variable-label-placement/"}],Un=[{title:"Change the case of labels",href:"https://maplibre.org/maplibre-gl-js-docs/example/change-case-of-labels/"}],Rn=[{title:"Change the case of labels",href:"https://maplibre.org/maplibre-gl-js-docs/example/change-case-of-labels/"},{title:"Display and style rich text labels",href:"https://maplibre.org/maplibre-gl-js-docs/example/display-and-style-rich-text-labels/"},{title:"Display buildings in 3D",href:"https://maplibre.org/maplibre-gl-js-docs/example/3d-buildings/"}],Hn=[{title:"Change the case of labels",href:"https://maplibre.org/maplibre-gl-js-docs/example/change-case-of-labels/"},{title:"Display HTML clusters with custom properties",href:"https://maplibre.org/maplibre-gl-js-docs/example/cluster-html/"},{title:"Extrude polygons for 3D indoor mapping",href:"https://maplibre.org/maplibre-gl-js-docs/example/3d-extrusion-floorplan/"}],Vn=[{title:"Create and style clusters",href:"https://maplibre.org/maplibre-gl-js-docs/example/cluster/"}],Jn=[{title:"Use a fallback image",href:"https://maplibre.org/maplibre-gl-js-docs/example/fallback-image/"}],Kn=[{title:"Animate map camera around a point",href:"https://maplibre.org/maplibre-gl-js-docs/example/animate-camera-around-point/"},{title:"Change building color based on zoom level",href:"https://maplibre.org/maplibre-gl-js-docs/example/change-building-color-based-on-zoom-level/"},{title:"Create a heatmap layer",href:"https://maplibre.org/maplibre-gl-js-docs/example/heatmap-layer/"},{title:"Visualize population density",href:"https://maplibre.org/maplibre-gl-js-docs/example/visualize-population-density/"}],Xn=[{title:"Display and style rich text labels",href:"https://maplibre.org/maplibre-gl-js-docs/example/display-and-style-rich-text-labels/"}],Gn=[{title:"Create and style clusters",href:"https://maplibre.org/maplibre-gl-js-docs/example/cluster/"}],Wn=[{title:"Change the case of labels",href:"https://maplibre.org/maplibre-gl-js-docs/example/change-case-of-labels/"}],Tt={"!":[{title:"Create and style clusters",href:"https://maplibre.org/maplibre-gl-js-docs/example/cluster/"}],"!=":[{title:"Display HTML clusters with custom properties",href:"https://maplibre.org/maplibre-gl-js-docs/example/cluster-html/"}],"/":[{title:"Visualize population density",href:"https://maplibre.org/maplibre-gl-js-docs/example/visualize-population-density/"}],"<":[{title:"Display HTML clusters with custom properties",href:"https://maplibre.org/maplibre-gl-js-docs/example/cluster-html/"}],"==":[{title:"Add multiple geometries from one GeoJSON source",href:"https://maplibre.org/maplibre-gl-js-docs/example/multiple-geometries/"},{title:"Create a time slider",href:"https://maplibre.org/maplibre-gl-js-docs/example/timeline-animation/"},{title:"Display buildings in 3D",href:"https://maplibre.org/maplibre-gl-js-docs/example/3d-buildings/"},{title:"Filter symbols by toggling a list",href:"https://maplibre.org/maplibre-gl-js-docs/example/filter-markers/"}],">=":[{title:"Display HTML clusters with custom properties",href:"https://maplibre.org/maplibre-gl-js-docs/example/cluster-html/"}],all:Pn,boolean:Fn,case:[{title:"Create a hover effect",href:"https://maplibre.org/maplibre-gl-js-docs/example/hover-styles/"},{title:"Display HTML clusters with custom properties",href:"https://maplibre.org/maplibre-gl-js-docs/example/cluster-html/"}],coalesce:Ln,concat:qn,downcase:Un,"feature-state":[{title:"Create a hover effect",href:"https://maplibre.org/maplibre-gl-js-docs/example/hover-styles/"}],format:Rn,get:Hn,has:Vn,image:Jn,in:[{title:"Measure distances",href:"https://maplibre.org/maplibre-gl-js-docs/example/measure/"}],interpolate:Kn,let:[{title:"Visualize population density",href:"https://maplibre.org/maplibre-gl-js-docs/example/visualize-population-density/"}],literal:Xn,"number-format":[{title:"Display HTML clusters with custom properties",href:"https://maplibre.org/maplibre-gl-js-docs/example/cluster-html/"}],step:Gn,"to-color":[{title:"Visualize population density",href:"https://maplibre.org/maplibre-gl-js-docs/example/visualize-population-density/"}],"to-string":[{title:"Create a time slider",href:"https://maplibre.org/maplibre-gl-js-docs/example/timeline-animation/"}],upcase:Wn,var:[{title:"Visualize population density",href:"https://maplibre.org/maplibre-gl-js-docs/example/visualize-population-density/"}]},Zn=Z('<h4 class="txt-bold mb6 unprose pt0">'),Bn=Z('<ul class="mb18">'),Yn=Z("<li><a>"),Qn=Z('<div class="mb12">'),ea=Z("<div>");function M(r){const e=zn.filter(a=>a.name===r.group)[0],t=({children:a})=>(()=>{const i=J(Zn);return i.style.setProperty("font-size","15px"),i.style.setProperty("font-weight","900"),i.style.setProperty("line-height","24px"),g(i,a),i})(),n=({links:a})=>{if(!(!a||!a.length===0))return[m(t,{children:"Related"}),(()=>{const i=J(Bn);return g(i,()=>a.map(s=>(()=>{const o=J(Yn),l=o.firstChild;return g(l,()=>s.title),Ir(()=>Mr(l,"href",s.href)),o})())),i})()]};return e.expressions.map(({name:a,doc:i,type:s,sdkSupport:o})=>[m(jr,{get id(){return`${e.name==="Types"?"types-":""}${a}`},children:a}),i&&(()=>{const l=J(Qn);return g(l,m(C,{content:i})),l})(),m(t,{children:"Syntax"}),ke(()=>s.map(l=>(()=>{const u=J(ea);return g(u,m(C,{get content(){return`
\`\`\`javascript
${On(a,l)}
\`\`\`
                    `}})),u})())),ke((()=>{const l=ke(()=>!!Tt[a]);return()=>l()&&m(n,{get links(){return Tt[a]}})})()),o&&m(Ar,{supportItems:o})])}const ta=Z("<div><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/><!#><!/>");function sa(){return(()=>{const r=J(ta),e=r.firstChild,[t,n]=x(e.nextSibling),a=t.nextSibling,[i,s]=x(a.nextSibling),o=i.nextSibling,[l,u]=x(o.nextSibling),c=l.nextSibling,[d,v]=x(c.nextSibling),w=d.nextSibling,[k,L]=x(w.nextSibling),R=k.nextSibling,[ie,H]=x(R.nextSibling),Xt=ie.nextSibling,[Qe,Gt]=x(Xt.nextSibling),Wt=Qe.nextSibling,[et,Zt]=x(Wt.nextSibling),Bt=et.nextSibling,[tt,Yt]=x(Bt.nextSibling),Qt=tt.nextSibling,[rt,er]=x(Qt.nextSibling),tr=rt.nextSibling,[nt,rr]=x(tr.nextSibling),nr=nt.nextSibling,[at,ar]=x(nr.nextSibling),ir=at.nextSibling,[it,sr]=x(ir.nextSibling),or=it.nextSibling,[st,lr]=x(or.nextSibling),ur=st.nextSibling,[ot,pr]=x(ur.nextSibling),cr=ot.nextSibling,[lt,fr]=x(cr.nextSibling),hr=lt.nextSibling,[ut,yr]=x(hr.nextSibling),dr=ut.nextSibling,[pt,mr]=x(dr.nextSibling),gr=pt.nextSibling,[ct,br]=x(gr.nextSibling),vr=ct.nextSibling,[ft,wr]=x(vr.nextSibling),kr=ft.nextSibling,[ht,xr]=x(kr.nextSibling),$r=ht.nextSibling,[yt,Tr]=x($r.nextSibling),Sr=yt.nextSibling,[Cr,_r]=x(Sr.nextSibling);return g(r,m(C,{get content(){return`
# Expressions

The value for any [layout property](/maplibre-style/layers/#layout-property), [paint property](/maplibre-style/layers/#paint-property), or [filter](/maplibre-style/layers/#filter) may be specified as an _expression_. An expression defines a formula for computing the value of the property using the _operators_ described below. The set of expression operators provided by MapLibre GL includes:

- Mathematical operators for performing arithmetic and other operations on numeric values
- Logical operators for manipulating boolean values and making conditional decisions
- String operators for manipulating strings
- Data operators, providing access to the properties of source features
- Camera operators, providing access to the parameters defining the current map view

Expressions are represented as JSON arrays. The first element of an expression array is a string naming the expression operator, e.g. [\`"*"\`](#*) or [\`"case"\`](#case). Elements that follow (if any) are the _arguments_ to the expression. Each argument is either a literal value (a string, number, boolean, or \`null\`), or another expression array.

\`\`\`json
[expression_name, argument_0, argument_1, ...]
\`\`\`

## Data expressions

A _data expression_ is any expression that access feature data -- that is, any expression that uses one of the data operators: [\`get\`](#get), [\`has\`](#has), [\`id\`](#id), [\`geometry-type\`](#geometry-type), [\`properties\`](#properties), or [\`feature-state\`](#feature-state). Data expressions allow a feature's properties or state to determine its appearance. They can be used to differentiate features within the same layer and to create data visualizations.

\`\`\`json
{
    "circle-color": [
        "rgb",
        // red is higher when feature.properties.temperature is higher
        ["get", "temperature"],
        // green is always zero
        0,
        // blue is higher when feature.properties.temperature is lower
        ["-", 100, ["get", "temperature"]]
    ]
}
\`\`\`

This example uses the [\`get\`](#get) operator to get the \`temperature\` value of each feature. That value is used to compute arguments to the [\`rgb\`](#rgb) operator, defining a color in terms of its red, green, and blue components.

Data expressions are allowed as the value of the [\`filter\`](/maplibre-style/layers/#filter) property, and as values for most paint and layout properties. However, some paint and layout properties do not yet support data expressions. The level of support is indicated by the "data-driven styling" row of the "SDK Support" table for each property. Data expressions with the [\`feature-state\`](#feature-state) operator are allowed only on paint properties.



## Camera expressions

A _camera expression_ is any expression that uses the [\`zoom\`](#zoom) operator. Such expressions allow the appearance of a layer to change with the map's zoom level. Camera expressions can be used to create the appearance of depth and to control data density.

\`\`\`json
{
    "circle-radius": [
        "interpolate", ["linear"], ["zoom"],
        // zoom is 5 (or less) -> circle radius will be 1px
        5, 1,
        // zoom is 10 (or greater) -> circle radius will be 5px
        10, 5
    ]
}
\`\`\`

This example uses the [\`interpolate\`](#interpolate) operator to define a linear relationship between zoom level and circle size using a set of input-output pairs. In this case, the expression indicates that the circle radius should be 1 pixel when the zoom level is 5 or below, and 5 pixels when the zoom is 10 or above. Between the two zoom levels, the circle radius will be linearly interpolated between 1 and 5 pixels

Camera expressions are allowed anywhere an expression may be used. When a camera expression used as the value of a layout or paint property, it must be in one of the following forms:

\`\`\`json
[ "interpolate", interpolation, ["zoom"], ... ]
\`\`\`

Or:

\`\`\`json
[ "step", ["zoom"], ... ]
\`\`\`

Or:

\`\`\`json
[
    "let",
    ... variable bindings...,
    [ "interpolate", interpolation, ["zoom"], ... ]
]
\`\`\`

Or:

\`\`\`json
[
    "let",
    ... variable bindings...,
    [ "step", ["zoom"], ... ]
]
\`\`\`

That is, in layout or paint properties, \`["zoom"]\` may appear only as the input to an outer [\`interpolate\`](#interpolate) or [\`step\`](#step) expression, or such an expression within a [\`let\`](#let) expression.

There is an important difference between layout and paint properties in the timing of camera expression evaluation. Paint property camera expressions are re-evaluated whenever the zoom level changes, even fractionally. For example, a paint property camera expression will be re-evaluated continuously as the map moves between zoom levels 4.1 and 4.6. A _layout property_ camera expression is evaluated only at integer zoom levels. It will _not_ be re-evaluated as the zoom changes from 4.1 to 4.6 -- only if it goes above 5 or below 4.

## Composition

A single expression may use a mix of data operators, camera operators, and other operators. Such composite expressions allows a layer's appearance to be determined by a combination of the zoom level _and_ individual feature properties.

\`\`\`json
{
    "circle-radius": [
        "interpolate", ["linear"], ["zoom"],
        // when zoom is 0, set each feature's circle radius to the value of its "rating" property
        0, ["get", "rating"],
        // when zoom is 10, set each feature's circle radius to four times the value of its "rating" property
        10, ["*", 4, ["get", "rating"]]
    ]
}
\`\`\`

An expression that uses both data and camera operators is considered both a data expression and a camera expression, and must adhere to the restrictions described above for both.

## Type system

The input arguments to expressions, and their result values, use the same set of [types](#types) as the rest of the style specification: boolean, string, number, color, and arrays of these types. Furthermore, expressions are _type safe_: each use of an expression has a known result type and required argument types, and the SDKs verify that the result type of an expression is appropriate for the context in which it is used. For example, the result type of an expression in the [\`filter\`](/maplibre-style/layers/#filter) property must be [boolean](#types-boolean), and the arguments to the [\`+\`](#+) operator must be [numbers](#types-number).

When working with feature data, the type of a feature property value is typically not known ahead of time by the SDK. To preserve type safety, when evaluating a data expression, the SDK will check that the property value is appropriate for the context. For example, if you use the expression \`["get", "feature-color"]\` for the [\`circle-color\`](#paint-circle-circle-color) property, the SDK will verify that the \`feature-color\` value of each feature is a string identifying a valid [color](#types-color). If this check fails, an error will be indicated in an SDK-specific way (typically a log message), and the default value for the property will be used instead.


In most cases, this verification will occur automatically wherever it is needed. However, in certain situations, the SDK may be unable to automatically determine the expected result type of a data expression from surrounding context. For example, it is not clear whether the expression \`["&lt;", ["get", "a"], ["get", "b"]]\` is attempting to compare strings or numbers. In situations like this, you can use one of the _type assertion_ expression operators to indicate the expected type of a data expression: \`["&lt;", ["number", ["get", "a"]], ["number", ["get", "b"]]]\`. A type assertion checks that the feature data matches the expected type of the data expression. If this check fails, it produces an error and causes the whole expression to fall back to the default value for the property being defined. The assertion operators are [\`array\`](#types-array), [\`boolean\`](#types-boolean), [\`number\`](#types-number), and [\`string\`](#types-string).

Expressions perform only one kind of implicit type conversion: a data expression used in a context where a [color](#types-color) is expected will convert a string representation of a color to a color value. In all other cases, if you want to convert between types, you must use one of the _type conversion_ expression operators: [\`to-boolean\`](#types-to-boolean), [\`to-number\`](#types-to-number), [\`to-string\`](#types-to-string), or [\`to-color\`](#types-to-color). For example, if you have a feature property that stores numeric values in string format, and you want to use those values as numbers rather than strings, you can use an expression such as \`["to-number", ["get", "property-name"]]\`.

If an expression accepts an array argument and the user supplies an array literal, that array _must_ be wrapped in a \`literal\` expression (see the examples below). When GL-JS encounters an array in a style-spec property value, it will assume that the array is an expression and try to parse it; the library has no way to distinguish between an expression which failed validation and an array literal unless the developer makes this distinction explicit with the \`literal\` operator. The \`literal\` operator is not necessary if the array is returned from a sub-expression, e.g. \`["in", 1, ["get", "myArrayProp"]]\`.

\`\`\`json
// will throw an error
{
    "circle-color": ["in", 1, [1, 2, 3]]
}

// will work as expected
{
    "circle-color": ["in", 1, ["literal", [1, 2, 3]]]
}
\`\`\`

`}}),t,n),g(r,m(C,{content:`
## Types

The expressions in this section are for testing for and converting between different data types like strings, numbers, and boolean values.

Often, such tests and conversions are unnecessary, but they may be necessary in some expressions where the type of a certain sub-expression is ambiguous. They can also be useful in cases where your feature data has inconsistent types; for example, you could use \`to-number\` to make sure that values like \`"1.5"\` (instead of \`1.5\`) are treated as numeric values.

`}),i,s),g(r,m(M,{group:"Types"}),l,u),g(r,m(C,{content:"## Feature data"}),d,v),g(r,m(M,{group:"Feature data"}),k,L),g(r,m(C,{content:"## Lookup"}),ie,H),g(r,m(M,{group:"Lookup"}),Qe,Gt),g(r,m(C,{content:`
## Decision

The expressions in this section can be used to add conditional logic to your styles. For example, the [\`'case'\`](#case)  expression provides "if/then/else" logic, and [\`'match'\`](#match) allows you to map specific values of an input expression to different output expressions.
`}),et,Zt),g(r,m(M,{group:"Decision"}),tt,Yt),g(r,m(C,{content:"## Ramps, scales, curves"}),rt,er),g(r,m(M,{group:"Ramps, scales, curves"}),nt,rr),g(r,m(C,{content:"## Variable binding"}),at,ar),g(r,m(M,{group:"Variable binding"}),it,sr),g(r,m(C,{content:"## String"}),st,lr),g(r,m(M,{group:"String"}),ot,pr),g(r,m(C,{content:"## Color"}),lt,fr),g(r,m(M,{group:"Color"}),ut,yr),g(r,m(C,{content:"## Math"}),pt,mr),g(r,m(M,{group:"Math"}),ct,br),g(r,m(C,{content:"## Zooming"}),ft,wr),g(r,m(M,{group:"Zoom"}),ht,xr),g(r,m(C,{content:"## Heatmap"}),yt,Tr),g(r,m(M,{group:"Heatmap"}),Cr,_r),r})()}export{sa as default};
